--- src/share/classes/com/sun/tools/javac/comp/Infer.java	2016-02-10 11:54:12.673195259 +0000
+++ src/share/classes/com/sun/tools/javac/comp/Infer.java	2016-02-11 09:51:02.050956918 +0000
@@ -25,18 +25,17 @@
 
 package com.sun.tools.javac.comp;
 
-import com.sun.tools.javac.tree.JCTree;
-import com.sun.tools.javac.tree.JCTree.JCTypeCast;
-import com.sun.tools.javac.tree.TreeInfo;
-import com.sun.tools.javac.util.*;
-import com.sun.tools.javac.util.List;
+import static com.sun.tools.javac.code.TypeTags.*;
+
+import javax.lang.model.type.TypeKind;
 import com.sun.tools.javac.code.*;
+import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.code.Type.*;
 import com.sun.tools.javac.code.Type.ForAll.ConstraintKind;
-import com.sun.tools.javac.code.Symbol.*;
-import com.sun.tools.javac.util.JCDiagnostic;
-
-import static com.sun.tools.javac.code.TypeTags.*;
+import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.TreeInfo;
+import com.sun.tools.javac.tree.JCTree.JCTypeCast;
+import com.sun.tools.javac.util.*;
 
 /** Helper class for type parameter inference, used by the attribution phase.
  *
@@ -57,6 +56,7 @@
     Check chk;
     Resolve rs;
     JCDiagnostic.Factory diags;
+    SourceLanguage sourceLanguage;
 
     public static Infer instance(Context context) {
         Infer instance = context.get(inferKey);
@@ -67,6 +67,7 @@
 
     protected Infer(Context context) {
         context.put(inferKey, this);
+        sourceLanguage = SourceLanguage.instance(context);
         syms = Symtab.instance(context);
         types = Types.instance(context);
         rs = Resolve.instance(context);
@@ -193,7 +194,12 @@
                         }
                     }
                 };
-                return constraintScanner.visit(uv);
+                boolean outerCyclic = false;
+                if (uv.inst instanceof Type.ClassType
+                        && ((Type.ClassType)uv.inst).getEnclosingType().getKind() != TypeKind.NONE) {
+                    outerCyclic = constraintScanner.visit(((Type.ClassType)uv.inst).getEnclosingType());
+                }
+                return outerCyclic || constraintScanner.visit(uv);
             }
         };
 
@@ -599,6 +605,15 @@
             if (args.head instanceof UndetVar ||
                     tvars.head.getUpperBound().isErroneous()) continue;
             List<Type> bounds = types.subst(types.getBounds((TypeVar)tvs.head), tvars, arguments);
+            /**
+             * In Ceylon if we want to add a type cast due to erasure to a parameter of a method, we must cast it
+             * to the first type of the bounds in order for it to work, since in Java we can't produce a type cast
+             * to multiple bounds (A&B), so we limit the check here to the first bound, which is how it is erased
+             * for raw types anyways.
+             * See https://github.com/ceylon/ceylon-compiler/issues/193
+             */
+            if(sourceLanguage.isCeylon() && bounds.size() > 1)
+                bounds = List.of(bounds.head);
             if (!types.isSubtypeUnchecked(args.head, bounds, warn))
                 throw invalidInstanceException
                     .setMessage("inferred.do.not.conform.to.bounds",
