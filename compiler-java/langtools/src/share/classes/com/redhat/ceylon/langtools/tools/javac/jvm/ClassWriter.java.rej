--- src/share/classes/com/sun/tools/javac/jvm/ClassWriter.java	2016-02-10 11:54:12.690194920 +0000
+++ src/share/classes/com/sun/tools/javac/jvm/ClassWriter.java	2016-02-11 09:51:01.979960687 +0000
@@ -26,13 +26,14 @@
 package com.sun.tools.javac.jvm;
 
 import java.io.*;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import java.util.Set;
 import java.util.HashSet;
 
-import javax.tools.JavaFileManager;
 import javax.tools.FileObject;
+import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
-
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
 import com.sun.tools.javac.code.Symbol.*;
@@ -38,15 +39,17 @@
 import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.code.Type.*;
 import com.sun.tools.javac.file.BaseFileObject;
+import com.sun.tools.javac.jvm.Pool.DynamicMethod;
+import com.sun.tools.javac.jvm.Pool.MethodHandle;
 import com.sun.tools.javac.util.*;
 
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
 import static com.sun.tools.javac.code.BoundKind.*;
 import static com.sun.tools.javac.code.Flags.*;
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.TypeTags.*;
 import static com.sun.tools.javac.jvm.UninitializedType.*;
 import static com.sun.tools.javac.main.OptionName.*;
-import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 
 /** This class provides operations to map an internal symbol table graph
@@ -170,7 +179,7 @@
 
     /** Construct a class writer, given an options table.
      */
-    private ClassWriter(Context context) {
+    protected ClassWriter(Context context) {
         context.put(classWriterKey, this);
 
         log = Log.instance(context);
@@ -384,7 +393,11 @@
             assembleClassSig(rawOuter
                              ? types.erasure(outer)
                              : outer);
-            sigbuf.appendByte('.');
+            // Ceylon: rawOuter represents local/anonymous types
+            // If we generate member types with '$' we get exceptions at runtime in reflection in 
+            // sun.reflect.generics.parser.SignatureParser.parsePackageNameAndSimpleClassTypeSignature()
+            // And if we generate local types with '.' we get the same exception, so be careful 
+            sigbuf.appendByte(rawOuter ? '$' : '.');
             Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
             sigbuf.appendName(rawOuter
                               ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength()+1,c.flatname.getByteLength())
@@ -483,11 +496,29 @@
 
             if (value instanceof MethodSymbol) {
                 MethodSymbol m = (MethodSymbol)value;
+                // Backported by Ceylon from JDK8
+                if (!m.isDynamic()) {
                 poolbuf.appendByte((m.owner.flags() & INTERFACE) != 0
                           ? CONSTANT_InterfaceMethodref
                           : CONSTANT_Methodref);
                 poolbuf.appendChar(pool.put(m.owner));
                 poolbuf.appendChar(pool.put(nameType(m)));
+                } else {
+                    //invokedynamic
+                    DynamicMethodSymbol dynSym = (DynamicMethodSymbol)m;
+                    MethodHandle handle = new MethodHandle(dynSym.bsmKind, dynSym.bsm);
+                    DynamicMethod dynMeth = new DynamicMethod(dynSym);
+                    bootstrapMethods.put(dynMeth, handle);
+                    //init cp entries
+                    pool.put(names.BootstrapMethods);
+                    pool.put(handle);
+                    for (Object staticArg : dynSym.staticArgs) {
+                        pool.put(staticArg);
+                    }
+                    poolbuf.appendByte(CONSTANT_InvokeDynamic);
+                    poolbuf.appendChar(bootstrapMethods.size() - 1);
+                    poolbuf.appendChar(pool.put(nameType(dynSym)));
+                }
             } else if (value instanceof VarSymbol) {
                 VarSymbol v = (VarSymbol)value;
                 poolbuf.appendByte(CONSTANT_Fieldref);
@@ -534,9 +565,21 @@
                 poolbuf.appendChar(pool.put(names.fromString((String)value)));
             } else if (value instanceof Type) {
                 Type type = (Type)value;
+                // Backported by Ceylon from JDK8
+                if (type instanceof MethodType) {
+                    poolbuf.appendByte(CONSTANT_MethodType);
+                    poolbuf.appendChar(pool.put(typeSig((MethodType)type)));
+                } else {
                 if (type.tag == CLASS) enterInner((ClassSymbol)type.tsym);
                 poolbuf.appendByte(CONSTANT_Class);
                 poolbuf.appendChar(pool.put(xClassName(type)));
+                }
+            // Backported by Ceylon from JDK8
+            } else if (value instanceof MethodHandle) {
+                MethodHandle ref = (MethodHandle)value;
+                poolbuf.appendByte(CONSTANT_MethodHandle);
+                poolbuf.appendByte(ref.refKind);
+                poolbuf.appendChar(pool.put(ref.refSym));
             } else {
                 Assert.error("writePool " + value);
             }
@@ -1500,6 +1565,8 @@
         pool = c.pool;
         innerClasses = null;
         innerClassesQueue = null;
+        // Backported by Ceylon from JDK8
+        bootstrapMethods = new LinkedHashMap<DynamicMethod, MethodHandle>();
 
         Type supertype = types.supertype(c.type);
         List<Type> interfaces = types.interfaces(c.type);
@@ -1597,6 +1664,13 @@
             writeInnerClasses();
             acount++;
         }
+
+        // Backported by Ceylon from JDK8
+        if (!bootstrapMethods.isEmpty()) {
+            writeBootstrapMethods();
+            acount++;
+        }
+
         endAttrs(acountIdx, acount);
 
         poolbuf.appendBytes(databuf.elems, 0, databuf.length);
