package com.redhat.ceylon.compiler.java.language;


import ceylon.language.finished_;
import ceylon.language.impl.BaseIterable;

import com.redhat.ceylon.compiler.java.metadata.Ignore;
import com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor;

/** 
 * A non-user-visible class that helps create iterables in 
 * generated bytecode. The {@link #iterator()} method should 
 * return a new instance in every call.
 * 
 * @author Enrique Zamudio
 */
public abstract class AbstractIterable<Element,Absent>
extends BaseIterable<Element,Absent>  {
    
//    @Ignore
//    private TypeDescriptor $reifiedElement;
//    @Ignore
//    private TypeDescriptor $reifiedAbsent;
//    
//    @Ignore
//    private final Iterable<?,?>[] $iterables;

    public AbstractIterable(@Ignore TypeDescriptor $reifiedElement, 
    		@Ignore TypeDescriptor $reifiedAbsent) {
    	super($reifiedElement, $reifiedAbsent);
//        this.$iterables = null;
    }
    
//    public AbstractIterable(@Ignore TypeDescriptor $reifiedElement, 
//    		@Ignore TypeDescriptor $reifiedAbsent, 
//    		Iterable<?,?>... iterables) {
//    	super($reifiedElement, $reifiedAbsent);
//    	this.$reifiedElement = $reifiedElement;
//    	this.$reifiedAbsent = $reifiedAbsent;
//        this.$iterables = iterables;
//    }
//    
//    @Ignore
//    public Iterable<?,?>[] $getIterables$() {
//        return $iterables;
//    }
    
    @Override
    public boolean getEmpty() {
        return iterator().next() == finished_.get_();
    }
    
//    @Override
//    @Ignore
//    public final TypeDescriptor $getType$() {
//        return TypeDescriptor.klass(AbstractIterable.class, 
//        		$reifiedElement, $reifiedAbsent);
//    }
    
    protected Object writeReplace() {
        return sequence();
    }
}
